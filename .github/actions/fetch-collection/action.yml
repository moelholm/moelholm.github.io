name: 'Fetch Collection'
description: 'DRY action to fetch/update a generated blog collection and open/update a PR'
inputs:
  script:
    description: 'Python script path (relative to repo root) to execute'
    required: true
  collection_dir:
    description: 'Path to collection directory to diff (e.g. site/blog_collections/_toots)'
    required: true
  assets_dir:
    description: 'Optional assets directory to include in diff (e.g. site/assets/toots_media)'
    required: false
  pr_branch:
    description: 'Branch name for PR (e.g. bot/mastodon-toots)'
    required: true
  pr_title:
    description: 'Pull request title'
    required: true
  pr_body:
    description: 'Pull request body'
    required: true
  pr_label:
    description: 'Label to apply (will be created if absent)'
    required: true
  python_deps:
    description: 'Space separated extra pip dependencies'
    required: false
  base_branch:
    description: 'Base branch'
    required: false
    default: 'master'

runs:
  using: 'composite'
  steps:
    - name: Checkout base branch
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.base_branch }}
        fetch-depth: 0

    - name: Configure Git user
      shell: bash
      run: |
        git config user.name 'github-actions[bot]'
        git config user.email 'github-actions[bot]@users.noreply.github.com'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Install dependencies
      shell: bash
      run: |
        set -euxo pipefail
        python -m pip install --upgrade pip
        # Base deps
        pip install requests html2text ${{ inputs.python_deps }} || pip install requests html2text

    - name: Prepare branch
      shell: bash
      run: |
        set -euxo pipefail
        base="${{ inputs.base_branch }}"
        pr_branch="${{ inputs.pr_branch }}"
        # Ensure remote URL is present (some prior actions/checkout combos can leave it detached)
        if ! git remote get-url origin >/dev/null 2>&1; then
          git remote add origin "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
        fi
        echo "Fetching base branch '$base' from origin..."
        # Fetch just the base branch (shallow is fine); avoid refspec overwriting that can delete tracking ref
        git fetch --force origin "$base" || {
          echo "::error::Failed to fetch origin/$base" >&2
          exit 1
        }
        # Determine ref to base
        if git show-ref --verify --quiet "refs/remotes/origin/$base"; then
          base_ref="origin/$base"
        elif git show-ref --verify --quiet "refs/heads/$base"; then
          base_ref="$base"
        else
          echo "::error::Base branch reference '$base' not found locally even after fetch." >&2
          git show-ref || true
          exit 1
        fi
        # Check if PR branch exists remotely and fetch it if so
        echo "Checking if PR branch '$pr_branch' exists remotely..."
        if git ls-remote --heads origin "$pr_branch" | grep -q "refs/heads/$pr_branch$"; then
          echo "PR branch exists remotely, fetching..."
          git fetch origin "$pr_branch" || {
            echo "::warning::Failed to fetch remote PR branch '$pr_branch'. The --force-with-lease protection cannot verify the remote state. If this occurs frequently, check for concurrent updates manually."
          }
        fi
        echo "Creating/updating work branch '$pr_branch' from $base_ref"
        git checkout -B "$pr_branch" "$base_ref"

    - name: Run fetch script
      shell: bash
      run: |
        set -euxo pipefail
        python ${{ inputs.script }}

    - name: Detect changes
      id: diff
      shell: bash
      run: |
        set -euo pipefail
        paths="${{ inputs.collection_dir }}"
        if [ -n "${{ inputs.assets_dir }}" ]; then
          paths="$paths ${{ inputs.assets_dir }}"
        fi
        # Gather tracked changes (modified/removed) and untracked (new) files
        tracked_changes=$(git diff --name-only -- $paths || true)
        untracked_changes=$(git ls-files --others --exclude-standard -- $paths || true)
        # Combine, de-duplicate, and drop empty lines
        all_changes=$(printf "%s\n%s\n" "$tracked_changes" "$untracked_changes" | sed '/^$/d' | sort -u)
        echo "Tracked changes:\n$tracked_changes"
        echo "Untracked changes:\n$untracked_changes"
        echo "All relevant changes (deduped):\n$all_changes"

        # Exclude meta-only change: if the only changed file ends with /meta.md (possibly multiple meta files across dirs) treat as no-op
        non_meta=$(echo "$all_changes" | grep -v '/meta\.md$' || true)
        if [ -z "$all_changes" ]; then
          echo "No changes detected in $paths" >> $GITHUB_STEP_SUMMARY
          echo "has_changes=false" >> $GITHUB_OUTPUT
        elif [ -z "$non_meta" ]; then
          echo "meta-only changes detected (ignored)" >> $GITHUB_STEP_SUMMARY
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Detected non-meta changes" >> $GITHUB_STEP_SUMMARY
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit & push
      if: steps.diff.outputs.has_changes == 'true'
      shell: bash
      run: |
        set -euxo pipefail
        git add ${{ inputs.collection_dir }}
        if [ -n "${{ inputs.assets_dir }}" ]; then
          git add ${{ inputs.assets_dir }}
        fi
        git commit -m "chore: refresh generated collection ${{ inputs.collection_dir }}"
        # Use force-with-lease to safely update the branch even if it diverged
        # This is safe because we always reset to base branch in the prepare step
        git push --force-with-lease -u origin ${{ inputs.pr_branch }}

    - name: Ensure label exists
      if: steps.diff.outputs.has_changes == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        gh label create ${{ inputs.pr_label }} --color EDEDED --description 'Automated content updates' || true

    - name: Create or update PR
      if: steps.diff.outputs.has_changes == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail
        existing=$(gh pr list --head ${{ inputs.pr_branch }} --state open --json number --jq '.[0].number' || true)
        if [ -z "$existing" ]; then
          gh pr create \
            --title "${{ inputs.pr_title }}" \
            --body "${{ inputs.pr_body }}" \
            --label "${{ inputs.pr_label }}" \
            --base "${{ inputs.base_branch }}" \
            --head "${{ inputs.pr_branch }}"
        else
          gh pr edit "$existing" --add-label "${{ inputs.pr_label }}"
        fi
